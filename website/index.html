<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>MATTERN42 NFT Collection</title>
		<script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Arial', sans-serif;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				min-height: 100vh;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				color: white;
			}

			.container {
				background: rgba(255, 255, 255, 0.1);
				backdrop-filter: blur(10px);
				border-radius: 20px;
				padding: 2rem;
				max-width: 600px;
				width: 90%;
				text-align: center;
				box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			}

			h1 {
				font-size: 2.5rem;
				margin-bottom: 1rem;
				background: linear-gradient(45deg, #ffd700, #ffa500);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
				background-clip: text;
			}

			.subtitle {
				font-size: 1.2rem;
				margin-bottom: 2rem;
				opacity: 0.8;
			}

			.nft-preview {
				background: rgba(255, 255, 255, 0.2);
				border-radius: 15px;
				padding: 1.5rem;
				margin-bottom: 2rem;
			}

			.nft-image {
				width: 200px;
				height: 200px;
				border-radius: 10px;
				background: rgba(255, 255, 255, 0.3);
				display: flex;
				align-items: center;
				justify-content: center;
				margin: 0 auto 1rem;
				font-size: 3rem;
			}

			.form-group {
				margin-bottom: 1.5rem;
				text-align: left;
			}

			label {
				display: block;
				margin-bottom: 0.5rem;
				font-weight: bold;
			}

			input {
				width: 100%;
				padding: 0.8rem;
				border: none;
				border-radius: 8px;
				background: rgba(255, 255, 255, 0.2);
				color: white;
				font-size: 1rem;
			}

			input::placeholder {
				color: rgba(255, 255, 255, 0.7);
			}

			.btn {
				background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
				color: white;
				border: none;
				padding: 1rem 2rem;
				border-radius: 50px;
				font-size: 1.1rem;
				font-weight: bold;
				cursor: pointer;
				transition: transform 0.3s ease;
				margin: 0.5rem;
			}

			.btn:hover {
				transform: translateY(-2px);
			}

			.btn:disabled {
				opacity: 0.5;
				cursor: not-allowed;
				transform: none;
			}

			.status {
				padding: 1rem;
				border-radius: 8px;
				margin-top: 1rem;
				font-weight: bold;
			}

			.status.success {
				background: rgba(76, 175, 80, 0.3);
				border: 1px solid #4caf50;
			}

			.status.error {
				background: rgba(244, 67, 54, 0.3);
				border: 1px solid #f44336;
			}

			.status.info {
				background: rgba(33, 150, 243, 0.3);
				border: 1px solid #2196f3;
			}

			.wallet-info {
				background: rgba(255, 255, 255, 0.2);
				border-radius: 10px;
				padding: 1rem;
				margin-bottom: 1.5rem;
				font-size: 0.9rem;
			}

			.hidden {
				display: none;
			}

			.stats {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
				gap: 1rem;
				margin-bottom: 2rem;
			}

			.stat-card {
				background: rgba(255, 255, 255, 0.2);
				border-radius: 10px;
				padding: 1rem;
			}

			.stat-number {
				font-size: 1.5rem;
				font-weight: bold;
				color: #ffd700;
			}

			.stat-label {
				font-size: 0.9rem;
				opacity: 0.8;
			}

			.nft-gallery {
				margin-top: 2rem;
				text-align: left;
			}

			.nft-gallery h4 {
				margin-bottom: 1rem;
				color: #ffd700;
			}

			.nft-list {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
				gap: 1rem;
			}

			.nft-card {
				background: rgba(255, 255, 255, 0.1);
				border-radius: 10px;
				padding: 1rem;
				text-align: center;
			}

			.nft-card img {
				width: 100%;
				height: 150px;
				object-fit: contain;
				border-radius: 8px;
				background: rgba(255, 255, 255, 0.2);
			}

			.nft-card h5 {
				margin: 0.5rem 0;
				color: #ffd700;
			}

			.nft-card p {
				font-size: 0.8rem;
				opacity: 0.8;
				margin: 0.2rem 0;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>🦡 MATTERN42 NFT</h1>
			<p class="subtitle">Mint your unique Badger #42 NFT on Sepolia</p>

			<!-- Contract Stats -->
			<div class="stats" id="stats">
				<div class="stat-card">
					<div class="stat-number" id="totalSupply">-</div>
					<div class="stat-label">Total Minted</div>
				</div>
				<div class="stat-card">
					<div class="stat-number" id="maxSupply">4242</div>
					<div class="stat-label">Max Supply</div>
				</div>
				<div class="stat-card">
					<div class="stat-number" id="userBalance">-</div>
					<div class="stat-label">Your NFTs</div>
				</div>
			</div>

			<!-- NFT Preview -->
			<div class="nft-preview">
				<div class="nft-image" id="nftPreview">🦡42</div>
				<h3>BADGER42 Collection</h3>
				<p>Unique digital art featuring the iconic number 42 - Stored fully on-chain!</p>
				<div id="nftGallery" class="nft-gallery hidden">
					<h4>Your NFTs:</h4>
					<div id="nftList" class="nft-list"></div>
				</div>
			</div>

			<!-- Wallet Connection -->
			<div id="connectSection">
				<button class="btn" onclick="connectWallet()">Connect Wallet</button>
				<p style="margin-top: 1rem; opacity: 0.8">Connect your MetaMask to start minting</p>
			</div>

			<!-- Wallet Info -->
			<div class="wallet-info hidden" id="walletInfo">
				<div><strong>Connected:</strong> <span id="walletAddress"></span></div>
				<div><strong>Network:</strong> <span id="networkName"></span></div>
				<div><strong>Balance:</strong> <span id="ethBalance"></span> ETH</div>
			</div>

			<!-- Mint Form -->
			<div id="mintSection" class="hidden">
				<div class="form-group">
					<label for="tokenURI">Metadata URI:</label>
					<input type="text" id="tokenURI" placeholder="ipfs://QmYourMetadataHash or QmHashForRelativeURI" value="" />
				</div>

				<div class="form-group">
					<label for="recipient">Recipient Address:</label>
					<input type="text" id="recipient" placeholder="0x... (leave empty to mint to yourself)" />
				</div>

				<button class="btn" onclick="mintNFT()" id="mintBtn">🎨 Mint NFT</button>

				<button class="btn" onclick="refreshStats()" style="background: linear-gradient(45deg, #95a5a6, #34495e)">🔄 Refresh</button>
			</div>

			<!-- Status Messages -->
			<div id="statusMessage"></div>
		</div>

		<script>
			// Configuration
			const CONFIG = {
				SEPOLIA_CHAIN_ID: 11155111,
				CONTRACT_ADDRESS: '', // Will be loaded from environment
				ETHERSCAN_URL: 'https://sepolia.etherscan.io',
				CURRENT_NETWORK: 'sepolia',
			};

			// Contract ABI (simplifié pour le mint)
			const CONTRACT_ABI = [
				'function mint(address to, string memory metadataURI, string memory artist) external',
				'function totalSupply() external view returns (uint256)',
				'function MAX_SUPPLY() external view returns (uint256)',
				'function balanceOf(address owner) external view returns (uint256)',
				'function ownerOf(uint256 tokenId) external view returns (address)',
				'function tokenURI(uint256 tokenId) external view returns (string memory)',
				'function name() external view returns (string memory)',
				'function symbol() external view returns (string memory)',
				'function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256)',
				'event NFTMinted(address indexed to, uint256 indexed tokenId, string tokenURI, string artist)',
			];

			let provider, signer, contract, userAddress;

			// Load contract address from local environment
			async function loadContractAddress() {
				try {
					const response = await fetch('/contract-address.json');
					if (response.ok) {
						const data = await response.json();
						CONFIG.CONTRACT_ADDRESS = data.address;
						console.log('Contract address loaded:', CONFIG.CONTRACT_ADDRESS);
					}
				} catch (error) {
					console.log('No contract address file found, will need manual input');
				}
			}

			// Connect to wallet
			async function connectWallet() {
				try {
					if (!window.ethereum) {
						showStatus('Please install MetaMask!', 'error');
						return;
					}

					showStatus('Connecting wallet...', 'info');

					await window.ethereum.request({ method: 'eth_requestAccounts' });
					provider = new ethers.BrowserProvider(window.ethereum);
					signer = await provider.getSigner();
					userAddress = await signer.getAddress();

					// Check network
					const network = await provider.getNetwork();

					if (Number(network.chainId) !== CONFIG.SEPOLIA_CHAIN_ID) {
						await switchToSepolia();
						return;
					}

					// Initialize contract
					if (CONFIG.CONTRACT_ADDRESS) {
						contract = new ethers.Contract(CONFIG.CONTRACT_ADDRESS, CONTRACT_ABI, signer);
					}

					updateUI();
					await refreshStats();
					showStatus('Wallet connected successfully!', 'success');
				} catch (error) {
					console.error('Connection error:', error);
					showStatus(`Connection failed: ${error.message}`, 'error');
				}
			}

			// Switch to Sepolia network
			async function switchToSepolia() {
				try {
					await window.ethereum.request({
						method: 'wallet_switchEthereumChain',
						params: [{ chainId: `0x${CONFIG.SEPOLIA_CHAIN_ID.toString(16)}` }],
					});
					location.reload();
				} catch (error) {
					if (error.code === 4902) {
						// Network not added, add it
						await window.ethereum.request({
							method: 'wallet_addEthereumChain',
							params: [
								{
									chainId: `0x${CONFIG.SEPOLIA_CHAIN_ID.toString(16)}`,
									chainName: 'Sepolia Test Network',
									nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
									rpcUrls: ['https://sepolia.infura.io/v3/'],
									blockExplorerUrls: ['https://sepolia.etherscan.io/'],
								},
							],
						});
					}
				}
			}

			// Update UI based on connection status
			function updateUI() {
				document.getElementById('connectSection').classList.add('hidden');
				document.getElementById('walletInfo').classList.remove('hidden');
				document.getElementById('mintSection').classList.remove('hidden');

				document.getElementById('walletAddress').textContent = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
				document.getElementById('networkName').textContent = 'Sepolia Testnet';
				document.getElementById('recipient').value = userAddress;

				updateBalance();
			}

			// Update ETH balance
			async function updateBalance() {
				try {
					const balance = await provider.getBalance(userAddress);
					document.getElementById('ethBalance').textContent = parseFloat(ethers.formatEther(balance)).toFixed(4);
				} catch (error) {
					console.error('Balance error:', error);
				}
			}

			// Refresh contract stats
			async function refreshStats() {
				if (!contract) {
					// Contract not deployed yet
					document.getElementById('totalSupply').textContent = '0';
					document.getElementById('userBalance').textContent = '0';
					showStatus('⚠️ Contract not deployed yet. Deploy first with: make deploy', 'info');
					return;
				}

				try {
					const totalSupply = await contract.totalSupply();
					const userBalance = await contract.balanceOf(userAddress);

					document.getElementById('totalSupply').textContent = totalSupply.toString();
					document.getElementById('userBalance').textContent = userBalance.toString();

					// Load user's NFTs if they have any
					if (userBalance > 0) {
						await loadUserNFTs();
					}
				} catch (error) {
					console.error('Stats error:', error);
					showStatus('Failed to load contract stats', 'error');
				}
			}

			// Load and display user's NFTs
			async function loadUserNFTs() {
				try {
					const balance = await contract.balanceOf(userAddress);
					const nftList = document.getElementById('nftList');
					const nftGallery = document.getElementById('nftGallery');
					
					if (balance == 0) {
						nftGallery.classList.add('hidden');
						return;
					}

					nftGallery.classList.remove('hidden');
					nftList.innerHTML = 'Loading your NFTs...';

					const nfts = [];
					
					// Get all tokens owned by user (simple approach)
					const totalSupply = await contract.totalSupply();
					for (let i = 1; i <= totalSupply; i++) {
						try {
							const owner = await contract.ownerOf(i);
							if (owner.toLowerCase() === userAddress.toLowerCase()) {
								const tokenURI = await contract.tokenURI(i);
								nfts.push({ id: i, uri: tokenURI });
							}
						} catch (error) {
							// Token might not exist, continue
						}
					}

					// Display NFTs
					if (nfts.length === 0) {
						nftList.innerHTML = '<p>No NFTs found</p>';
						return;
					}

					nftList.innerHTML = '';
					for (const nft of nfts) {
						const nftCard = await createNFTCard(nft.id, nft.uri);
						nftList.appendChild(nftCard);
					}
				} catch (error) {
					console.error('Error loading NFTs:', error);
					document.getElementById('nftList').innerHTML = '<p>Error loading NFTs</p>';
				}
			}

			// Create NFT card element
			async function createNFTCard(tokenId, tokenURI) {
				const card = document.createElement('div');
				card.className = 'nft-card';

				try {
					let metadata;
					
					console.log('Loading metadata for token', tokenId, 'URI:', tokenURI);
					
					// Handle data URI (on-chain metadata)
					if (tokenURI.startsWith('data:application/json;base64,')) {
						const base64Data = tokenURI.split(',')[1];
						console.log('Base64 data:', base64Data);
						
						try {
							const jsonData = atob(base64Data);
							console.log('Raw decoded data length:', jsonData.length);
							console.log('First 100 chars:', JSON.stringify(jsonData.substring(0, 100)));
							
							let cleanJson = '';
							
							// Check if the JSON starts with 'cription' (missing 'des' prefix)
							if (jsonData.startsWith('cription')) {
								// Reconstruct the missing part
								cleanJson = '{"description":"' + jsonData.substring('cription":"'.length);
								console.log('Fixed missing description prefix');
							} else {
								// Find the actual JSON start - look for the first '{'
								const jsonStart = jsonData.indexOf('{');
								if (jsonStart >= 0) {
									cleanJson = jsonData.substring(jsonStart);
								} else {
									throw new Error('No JSON object found in decoded data');
								}
							}
							
							// Find the end of valid JSON by counting braces
							let braceCount = 0;
							let validEnd = -1;
							
							for (let i = 0; i < cleanJson.length; i++) {
								const char = cleanJson[i];
								if (char === '{') {
									braceCount++;
								} else if (char === '}') {
									braceCount--;
									if (braceCount === 0) {
										validEnd = i;
										break;
									}
								}
							}
							
							if (validEnd > 0) {
								cleanJson = cleanJson.substring(0, validEnd + 1);
							}
							
							console.log('Clean JSON to parse (first 200 chars):', cleanJson.substring(0, 200));
							metadata = JSON.parse(cleanJson);
							console.log('Successfully parsed metadata:', metadata);
						} catch (parseError) {
							console.error('Error parsing base64 data:', parseError);
							throw parseError;
						}
					} else if (tokenURI.startsWith('ipfs://')) {
						// Handle IPFS URLs
						const ipfsUrl = tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/');
						const response = await fetch(ipfsUrl);
						metadata = await response.json();
					} else if (tokenURI.startsWith('http')) {
						// Handle direct HTTP URLs
						const response = await fetch(tokenURI);
						metadata = await response.json();
					} else {
						throw new Error('Unsupported URI format');
					}

					// Handle different image data formats
					let imageUrl = '';
					if (metadata.image) {
						imageUrl = metadata.image;
					} else if (metadata.imageData) {
						imageUrl = metadata.imageData;
					}

					// Convert IPFS image URLs if needed
					if (imageUrl.startsWith('ipfs://')) {
						imageUrl = imageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
					}

					card.innerHTML = `
						<img src="${imageUrl}" alt="${metadata.name || 'NFT'}" 
							 onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjNjY3ZWVhIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj7wn6qhNDI8L3RleHQ+PC9zdmc+'" />
						<h5>${metadata.name || `NFT #${tokenId}`}</h5>
						<p><strong>Token ID:</strong> ${tokenId}</p>
						<p><strong>Artist:</strong> ${metadata.artist || 'Unknown'}</p>
						<p>${metadata.description ? (metadata.description.length > 60 ? metadata.description.substring(0, 60) + '...' : metadata.description) : 'No description'}</p>
						<a href="${CONFIG.ETHERSCAN_URL}/token/${CONFIG.CONTRACT_ADDRESS}?a=${tokenId}" target="_blank" style="color: #ffd700; text-decoration: none; font-size: 0.8rem;">View on Etherscan</a>
					`;
				} catch (error) {
					console.error('Error loading metadata for token', tokenId, error);
					card.innerHTML = `
						<div style="width: 100%; height: 150px; background: rgba(255,255,255,0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 2rem;">🦡42</div>
						<h5>NFT #${tokenId}</h5>
						<p><strong>Token ID:</strong> ${tokenId}</p>
						<p>Error: ${error.message}</p>
						<a href="${CONFIG.ETHERSCAN_URL}/token/${CONFIG.CONTRACT_ADDRESS}?a=${tokenId}" target="_blank" style="color: #ffd700; text-decoration: none; font-size: 0.8rem;">View on Etherscan</a>
					`;
				}

				return card;
			}

			// Mint NFT
			async function mintNFT() {
				if (!contract) {
					showStatus('Please deploy the contract first: make deploy', 'error');
					return;
				}

				const tokenURI = document.getElementById('tokenURI').value.trim();
				const recipient = document.getElementById('recipient').value.trim() || userAddress;

				if (!tokenURI) {
					showStatus('Please enter a metadata URI', 'error');
					return;
				}

				if (!ethers.isAddress(recipient)) {
					showStatus('Invalid recipient address', 'error');
					return;
				}

				try {
					document.getElementById('mintBtn').disabled = true;
					document.getElementById('mintBtn').textContent = 'Minting...';

					showStatus('Preparing mint transaction...', 'info');

					const tx = await contract.mint(recipient, tokenURI, 'lmattern');

					showStatus(`Transaction sent: ${tx.hash}`, 'info');

					const receipt = await tx.wait();

					showStatus(`✅ NFT minted successfully! Transaction: ${tx.hash}`, 'success');

					// Add explorer link
					const explorerUrl = `${CONFIG.ETHERSCAN_URL}/tx/${tx.hash}`;

					setTimeout(() => {
						showStatus(`✅ NFT minted! View on <a href="${explorerUrl}" target="_blank">Etherscan</a>`, 'success');
					}, 2000);

					await refreshStats();
				} catch (error) {
					console.error('Mint error:', error);
					showStatus(`Mint failed: ${error.message}`, 'error');
				} finally {
					document.getElementById('mintBtn').disabled = false;
					document.getElementById('mintBtn').textContent = '🎨 Mint NFT';
				}
			}

			// Show status message
			function showStatus(message, type) {
				const statusEl = document.getElementById('statusMessage');
				statusEl.innerHTML = message;
				statusEl.className = `status ${type}`;
				statusEl.style.display = 'block';

				if (type === 'success') {
					setTimeout(() => {
						statusEl.style.display = 'none';
					}, 10000);
				}
			}

			// Auto-connect if previously connected
			window.addEventListener('load', async () => {
				await loadContractAddress();
				if (window.ethereum && window.ethereum.selectedAddress) {
					await connectWallet();
				}
			});

			// Handle account changes
			if (window.ethereum) {
				window.ethereum.on('accountsChanged', (accounts) => {
					if (accounts.length === 0) {
						location.reload();
					} else {
						connectWallet();
					}
				});

				window.ethereum.on('chainChanged', () => {
					location.reload();
				});
			}
		</script>
	</body>
</html>
